{"ast":null,"code":"/* eslint no-underscore-dangle: \"off\" */\nimport { window, document } from 'ssr-window';\nimport $ from 'dom7';\nimport Template7 from 'template7';\nimport Utils from '../../utils/utils';\nimport vdom from './vdom';\nimport patch from './patch';\nimport componentMixins from './component-mixins';\n\nclass Component {\n  constructor(app) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let extendContext = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    let children = arguments.length > 3 ? arguments[3] : undefined;\n    const id = Utils.id();\n    const self = this;\n    Utils.merge(self, {\n      $props: {}\n    }, extendContext, {\n      $,\n      $$: $,\n      $dom7: $,\n      $app: app,\n      $f7: app,\n      $options: Utils.extend({\n        id\n      }, options),\n      $id: options.isClassComponent ? self.constructor.id : options.id || id,\n      $mixins: options.isClassComponent ? self.constructor.mixins : options.mixins,\n      $children: children || []\n    });\n    const {\n      $options\n    } = self;\n\n    if (self.$mixins && self.$mixins.length) {\n      for (let i = self.$mixins.length - 1; i >= 0; i -= 1) {\n        const mixin = self.$mixins[i];\n\n        if (typeof mixin === 'string') {\n          if (componentMixins[mixin]) self.$mixins[i] = componentMixins[mixin];else self.$mixins.splice(i, 1);\n        }\n      }\n    }\n\n    Object.defineProperty(self, '$slots', {\n      enumerable: true,\n      configurable: true,\n\n      get() {\n        const slots = {};\n        self.$children.forEach(childVNode => {\n          let childSlotName = 'default';\n\n          if (childVNode.data) {\n            childSlotName = childVNode.data.attrs && childVNode.data.attrs.slot || 'default';\n          }\n\n          if (!slots[childSlotName]) slots[childSlotName] = [];\n          slots[childSlotName].push(childVNode);\n        });\n        return slots;\n      }\n\n    }); // Root data and methods\n\n    Object.defineProperty(self, '$root', {\n      enumerable: true,\n      configurable: true,\n\n      get() {\n        let root = Utils.merge({}, app.data, app.methods);\n\n        if (window && window.Proxy) {\n          root = new window.Proxy(root, {\n            set(target, name, val) {\n              app.data[name] = val;\n            },\n\n            deleteProperty(target, name) {\n              delete app.data[name];\n              delete app.methods[name];\n            },\n\n            has(target, name) {\n              return name in app.data || name in app.methods;\n            }\n\n          });\n        }\n\n        return root;\n      },\n\n      set() {}\n\n    }); // Bind render\n\n    if ($options.render) $options.render = $options.render.bind(self); // Bind methods\n\n    const methods = {};\n\n    if (self.$mixins && self.$mixins.length) {\n      self.$mixins.forEach(mixin => {\n        if (mixin.methods) Object.assign(methods, mixin.methods);\n      });\n    }\n\n    if ($options.methods) {\n      Object.assign(methods, $options.methods);\n    }\n\n    Object.keys(methods).forEach(methodName => {\n      self[methodName] = methods[methodName].bind(self);\n    }); // Bind Events\n\n    if ($options.on) {\n      Object.keys($options.on).forEach(eventName => {\n        $options.on[eventName] = $options.on[eventName].bind(self);\n      });\n    }\n\n    if ($options.once) {\n      Object.keys($options.once).forEach(eventName => {\n        $options.once[eventName] = $options.once[eventName].bind(self);\n      });\n    }\n\n    return new Promise((resolve, reject) => {\n      self.$hook('data', true).then(datas => {\n        const data = {};\n        datas.forEach(dt => {\n          Object.assign(data, dt || {});\n        });\n        Utils.extend(self, data);\n        self.$hook('beforeCreate');\n        let html = self.$render();\n        const style = $options.isClassComponent ? self.constructor.style : $options.style;\n        const styleScoped = $options.isClassComponent ? self.constructor.styleScoped : $options.styleScoped;\n\n        if (self.$options.el) {\n          html = html.trim();\n          self.$vnode = vdom(html, self, true);\n\n          if (style) {\n            self.$styleEl = document.createElement('style');\n            self.$styleEl.innerHTML = style;\n\n            if (styleScoped) {\n              self.$vnode.data.attrs[`data-f7-${self.$id}`] = '';\n            }\n          }\n\n          self.el = self.$options.el;\n          patch(self.el, self.$vnode);\n          self.el = self.$vnode.elm;\n          self.$el = $(self.el);\n          self.$attachEvents();\n          self.el.f7Component = self;\n          self.$hook('created');\n          self.$mount();\n          resolve(self);\n          return;\n        } // Make Dom\n\n\n        if (html && typeof html === 'string') {\n          html = html.trim();\n          self.$vnode = vdom(html, self, true);\n\n          if (style && styleScoped) {\n            self.$vnode.data.attrs[`data-f7-${self.$id}`] = '';\n          }\n\n          self.el = document.createElement(self.$vnode.sel || 'div');\n          patch(self.el, self.$vnode);\n          self.$el = $(self.el);\n        } else if (html) {\n          self.el = html;\n          self.$el = $(self.el);\n\n          if (style && styleScoped) {\n            self.el.setAttribute(`data-f7-${self.$id}`, '');\n          }\n        }\n\n        if (style) {\n          self.$styleEl = document.createElement('style');\n          self.$styleEl.innerHTML = style;\n        }\n\n        self.$attachEvents();\n\n        if (self.el) {\n          self.el.f7Component = self;\n        }\n\n        self.$hook('created');\n        resolve(self);\n      }).catch(err => {\n        reject(err);\n      });\n    });\n  }\n\n  $attachEvents() {\n    const self = this;\n    const {\n      $options,\n      $el\n    } = self;\n\n    if (self.$mixins && self.$mixins.length) {\n      self.$detachEventsHandlers = {};\n      self.$mixins.forEach(mixin => {\n        if (mixin.on) {\n          Object.keys(mixin.on).forEach(eventName => {\n            const handler = mixin.on[eventName].bind(self);\n            if (!self.$detachEventsHandlers[eventName]) self.$detachEventsHandlers[eventName] = [];\n            self.$detachEventsHandlers[eventName].push(handler);\n            $el.on(Utils.eventNameToColonCase(eventName), handler);\n          });\n        }\n\n        if (mixin.once) {\n          Object.keys(mixin.once).forEach(eventName => {\n            const handler = mixin.once[eventName].bind(self);\n            if (!self.$detachEventsHandlers[eventName]) self.$detachEventsHandlers[eventName] = [];\n            self.$detachEventsHandlers[eventName].push(handler);\n            $el.once(Utils.eventNameToColonCase(eventName), handler);\n          });\n        }\n      });\n    }\n\n    if ($options.on) {\n      Object.keys($options.on).forEach(eventName => {\n        $el.on(Utils.eventNameToColonCase(eventName), $options.on[eventName]);\n      });\n    }\n\n    if ($options.once) {\n      Object.keys($options.once).forEach(eventName => {\n        $el.once(Utils.eventNameToColonCase(eventName), $options.once[eventName]);\n      });\n    }\n  }\n\n  $detachEvents() {\n    const self = this;\n    const {\n      $options,\n      $el\n    } = self;\n\n    if ($options.on) {\n      Object.keys($options.on).forEach(eventName => {\n        $el.off(Utils.eventNameToColonCase(eventName), $options.on[eventName]);\n      });\n    }\n\n    if ($options.once) {\n      Object.keys($options.once).forEach(eventName => {\n        $el.off(Utils.eventNameToColonCase(eventName), $options.once[eventName]);\n      });\n    }\n\n    if (!self.$detachEventsHandlers) return;\n    Object.keys(self.$detachEventsHandlers).forEach(eventName => {\n      const handlers = self.$detachEventsHandlers[eventName];\n      handlers.forEach(handler => {\n        $el.off(Utils.eventNameToColonCase(eventName), handler);\n      });\n      self.$detachEventsHandlers[eventName] = [];\n      delete self.$detachEventsHandlers[eventName];\n    });\n    self.$detachEventsHandlers = null;\n    delete self.$detachEventsHandlers;\n  }\n\n  $render() {\n    const self = this;\n    const {\n      $options\n    } = self;\n    let html = '';\n\n    if ($options.render) {\n      html = $options.render();\n    } else if (self.render) {\n      html = self.render.call(self);\n    } else if ($options.template) {\n      if (typeof $options.template === 'string') {\n        html = Template7.compile($options.template)(self);\n      } else {\n        // Supposed to be function\n        html = $options.template(self);\n      }\n    }\n\n    return html;\n  }\n\n  $tick(callback) {\n    const self = this;\n    return new Promise(resolve => {\n      window.requestAnimationFrame(() => {\n        if (self.__updateIsPending) {\n          window.requestAnimationFrame(() => {\n            resolve();\n            callback();\n          });\n        } else {\n          resolve();\n          callback();\n        }\n      });\n    });\n  }\n\n  $update(callback) {\n    const self = this;\n    window.cancelAnimationFrame(self.__requestAnimationFrameId);\n    delete self.__requestAnimationFrameId;\n    self.__updateIsPending = true;\n    return new Promise(resolve => {\n      self.__requestAnimationFrameId = window.requestAnimationFrame(() => {\n        let html = self.$render(); // Make Dom\n\n        if (html && typeof html === 'string') {\n          html = html.trim();\n          const newVNode = vdom(html, self, false);\n          self.$vnode = patch(self.$vnode, newVNode);\n        }\n\n        self.__updateIsPending = false;\n        delete self.__updateIsPending;\n        if (callback) callback();\n        resolve();\n      });\n    });\n  }\n\n  $setState(mergeState, callback) {\n    const self = this;\n    Utils.merge(self, mergeState);\n    return self.$update(callback);\n  }\n\n  $mount(mountMethod) {\n    const self = this;\n    self.$hook('beforeMount');\n    if (self.$styleEl) $('head').append(self.$styleEl);\n    if (mountMethod) mountMethod(self.el);\n    self.$hook('mounted');\n  }\n\n  $destroy() {\n    const self = this;\n    self.$hook('beforeDestroy');\n    if (self.$styleEl) $(self.$styleEl).remove();\n    self.$detachEvents();\n    self.$hook('destroyed'); // Delete component instance\n\n    if (self.el && self.el.f7Component) {\n      self.el.f7Component = null;\n      delete self.el.f7Component;\n    } // Patch with empty node\n\n\n    if (self.$vnode) {\n      self.$vnode = patch(self.$vnode, {\n        sel: self.$vnode.sel,\n        data: {}\n      });\n    } // Clear update queue\n\n\n    window.cancelAnimationFrame(self.__requestAnimationFrameId); // Delete all props\n\n    Utils.deleteProps(self);\n  }\n\n  $hook(name, async) {\n    const self = this;\n\n    if (async) {\n      const promises = [];\n\n      if (self.$mixins && self.$mixins.length) {\n        self.$mixins.forEach(mixin => {\n          if (mixin[name]) promises.push(mixin[name].call(self));\n        });\n      }\n\n      if (self[name]) {\n        promises.push(self[name].call(self));\n      }\n\n      if (self.$options[name]) {\n        promises.push(self.$options[name].call(self));\n      }\n\n      return Promise.all(promises);\n    }\n\n    if (self.$mixins && self.$mixins.length) {\n      self.$mixins.forEach(mixin => {\n        if (mixin[name] && typeof mixin[name] === 'function') {\n          mixin[name].call(self);\n        }\n      });\n    }\n\n    if (self.$options[name]) return self.$options[name].call(self);\n    if (self[name]) return self[name].call(self);\n    return undefined;\n  }\n\n}\n\nexport default Component;","map":null,"metadata":{},"sourceType":"module"}