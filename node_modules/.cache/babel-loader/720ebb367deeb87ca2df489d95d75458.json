{"ast":null,"code":"import React, { forwardRef, useEffect, useImperativeHandle, useMemo, useRef, useState } from 'react';\nimport { withNativeProps } from '../../utils/native-props';\nimport { mergeProps } from '../../utils/with-default-props';\nimport classNames from 'classnames';\nimport { SwiperItem } from './swiper-item';\nimport { devWarning } from '../../utils/dev-log';\nimport { useSpring, animated } from '@react-spring/web';\nimport { useDrag } from '@use-gesture/react';\nimport PageIndicator from '../page-indicator';\nimport { staged } from 'staged-components';\nimport { useRefState } from '../../utils/use-ref-state';\nimport { bound } from '../../utils/bound';\nimport { useIsomorphicLayoutEffect } from 'ahooks';\nimport { mergeFuncProps } from '../../utils/with-func-props';\nconst classPrefix = `adm-swiper`;\nconst eventToPropRecord = {\n  'mousedown': 'onMouseDown',\n  'mousemove': 'onMouseMove',\n  'mouseup': 'onMouseUp'\n};\nconst defaultProps = {\n  defaultIndex: 0,\n  allowTouchMove: true,\n  autoplay: false,\n  autoplayInterval: 3000,\n  loop: false,\n  direction: 'horizontal',\n  slideSize: 100,\n  trackOffset: 0,\n  stuckAtBoundary: true,\n  rubberband: true,\n  stopPropagation: []\n};\nlet currentUid;\nexport const Swiper = forwardRef(staged((p, ref) => {\n  const props = mergeProps(defaultProps, p);\n  const [uid] = useState({});\n  const isVertical = props.direction === 'vertical';\n  const slideRatio = props.slideSize / 100;\n  const offsetRatio = props.trackOffset / 100;\n  const {\n    validChildren,\n    count\n  } = useMemo(() => {\n    let count = 0;\n    const validChildren = React.Children.map(props.children, child => {\n      if (!React.isValidElement(child)) return null;\n\n      if (child.type !== SwiperItem) {\n        devWarning('Swiper', 'The children of `Swiper` must be `Swiper.Item` components.');\n        return null;\n      }\n\n      count++;\n      return child;\n    });\n    return {\n      validChildren,\n      count\n    };\n  }, [props.children]);\n\n  if (count === 0 || !validChildren) {\n    devWarning('Swiper', '`Swiper` needs at least one child.');\n    return null;\n  }\n\n  return () => {\n    let loop = props.loop;\n\n    if (slideRatio * (count - 1) < 1) {\n      loop = false;\n    }\n\n    const trackRef = useRef(null);\n\n    function getSlidePixels() {\n      const track = trackRef.current;\n      if (!track) return 0;\n      const trackPixels = isVertical ? track.offsetHeight : track.offsetWidth;\n      return trackPixels * props.slideSize / 100;\n    }\n\n    const [current, setCurrent] = useState(props.defaultIndex);\n    const [dragging, setDragging, draggingRef] = useRefState(false);\n\n    function boundIndex(current) {\n      let min = 0;\n      let max = count - 1;\n\n      if (props.stuckAtBoundary) {\n        min += offsetRatio / slideRatio;\n        max -= (1 - slideRatio - offsetRatio) / slideRatio;\n      }\n\n      return bound(current, min, max);\n    }\n\n    const [{\n      position\n    }, api] = useSpring(() => ({\n      position: boundIndex(current) * 100,\n      config: {\n        tension: 200,\n        friction: 30\n      },\n      onRest: () => {\n        if (draggingRef.current) return;\n        if (!loop) return;\n        const rawX = position.get();\n        const totalWidth = 100 * count;\n        const standardPosition = modulus(rawX, totalWidth);\n        if (standardPosition === rawX) return;\n        api.start({\n          position: standardPosition,\n          immediate: true\n        });\n      }\n    }), [count]);\n    const dragCancelRef = useRef(null);\n\n    function forceCancelDrag() {\n      var _a;\n\n      (_a = dragCancelRef.current) === null || _a === void 0 ? void 0 : _a.call(dragCancelRef);\n      draggingRef.current = false;\n    }\n\n    const bind = useDrag(state => {\n      dragCancelRef.current = state.cancel;\n      if (!state.intentional) return;\n\n      if (state.first && !currentUid) {\n        currentUid = uid;\n      }\n\n      if (currentUid !== uid) return;\n      currentUid = state.last ? undefined : uid;\n      const slidePixels = getSlidePixels();\n      if (!slidePixels) return;\n      const paramIndex = isVertical ? 1 : 0;\n      const offset = state.offset[paramIndex];\n      const direction = state.direction[paramIndex];\n      const velocity = state.velocity[paramIndex];\n      setDragging(true);\n\n      if (!state.last) {\n        api.start({\n          position: offset * 100 / slidePixels,\n          immediate: true\n        });\n      } else {\n        const minIndex = Math.floor(offset / slidePixels);\n        const maxIndex = minIndex + 1;\n        const index = Math.round((offset + velocity * 2000 * direction) / slidePixels);\n        swipeTo(bound(index, minIndex, maxIndex));\n        window.setTimeout(() => {\n          setDragging(false);\n        });\n      }\n    }, {\n      transform: _ref => {\n        let [x, y] = _ref;\n        return [-x, -y];\n      },\n      from: () => {\n        const slidePixels = getSlidePixels();\n        return [position.get() / 100 * slidePixels, position.get() / 100 * slidePixels];\n      },\n      triggerAllEvents: true,\n      bounds: () => {\n        if (loop) return {};\n        const slidePixels = getSlidePixels();\n        const lowerBound = boundIndex(0) * slidePixels;\n        const upperBound = boundIndex(count - 1) * slidePixels;\n        return isVertical ? {\n          top: lowerBound,\n          bottom: upperBound\n        } : {\n          left: lowerBound,\n          right: upperBound\n        };\n      },\n      rubberband: props.rubberband,\n      axis: isVertical ? 'y' : 'x',\n      preventScroll: !isVertical,\n      pointer: {\n        touch: true\n      }\n    });\n\n    function swipeTo(index) {\n      let immediate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n      var _a;\n\n      const roundedIndex = Math.round(index);\n      const targetIndex = loop ? modulus(roundedIndex, count) : bound(roundedIndex, 0, count - 1);\n      setCurrent(targetIndex);\n\n      if (targetIndex !== current) {\n        (_a = props.onIndexChange) === null || _a === void 0 ? void 0 : _a.call(props, targetIndex);\n      }\n\n      api.start({\n        position: (loop ? roundedIndex : boundIndex(roundedIndex)) * 100,\n        immediate\n      });\n    }\n\n    function swipeNext() {\n      swipeTo(Math.round(position.get() / 100) + 1);\n    }\n\n    function swipePrev() {\n      swipeTo(Math.round(position.get() / 100) - 1);\n    }\n\n    useImperativeHandle(ref, () => ({\n      swipeTo,\n      swipeNext,\n      swipePrev\n    }));\n    useIsomorphicLayoutEffect(() => {\n      const maxIndex = validChildren.length - 1;\n\n      if (current > maxIndex) {\n        swipeTo(maxIndex, true);\n      }\n    });\n    const {\n      autoplay,\n      autoplayInterval\n    } = props;\n    useEffect(() => {\n      if (!autoplay || dragging) return;\n      let interval;\n\n      function tick() {\n        interval = window.setTimeout(tick, autoplayInterval);\n        swipeNext();\n      }\n\n      interval = window.setTimeout(tick, autoplayInterval);\n      return () => {\n        if (interval) window.clearTimeout(interval);\n      };\n    }, [autoplay, autoplayInterval, dragging, count]);\n\n    function renderTrackInner() {\n      if (loop) {\n        return React.createElement(\"div\", {\n          className: `${classPrefix}-track-inner`\n        }, React.Children.map(validChildren, (child, index) => {\n          return React.createElement(animated.div, {\n            className: classNames(`${classPrefix}-slide`, {\n              [`${classPrefix}-slide-active`]: current === index\n            }),\n            style: {\n              [isVertical ? 'y' : 'x']: position.to(position => {\n                let finalPosition = -position + index * 100;\n                const totalWidth = count * 100;\n                const flagWidth = totalWidth / 2;\n                finalPosition = modulus(finalPosition + flagWidth, totalWidth) - flagWidth;\n                return `${finalPosition}%`;\n              }),\n              [isVertical ? 'top' : 'left']: `-${index * 100}%`\n            }\n          }, child);\n        }));\n      } else {\n        return React.createElement(animated.div, {\n          className: `${classPrefix}-track-inner`,\n          style: {\n            [isVertical ? 'y' : 'x']: position.to(position => `${-position}%`)\n          }\n        }, React.Children.map(validChildren, child => {\n          return React.createElement(\"div\", {\n            className: `${classPrefix}-slide`\n          }, child);\n        }));\n      }\n    }\n\n    const style = {\n      '--slide-size': `${props.slideSize}%`,\n      '--track-offset': `${props.trackOffset}%`\n    };\n    const dragProps = Object.assign({}, props.allowTouchMove ? bind() : {});\n    const stopPropagationProps = {};\n\n    for (const key of props.stopPropagation) {\n      const prop = eventToPropRecord[key];\n\n      stopPropagationProps[prop] = function (e) {\n        e.stopPropagation();\n      };\n    }\n\n    const mergedProps = mergeFuncProps(dragProps, stopPropagationProps);\n    return withNativeProps(props, React.createElement(\"div\", {\n      className: classNames(classPrefix, `${classPrefix}-${props.direction}`),\n      style: style\n    }, React.createElement(\"div\", Object.assign({\n      ref: trackRef,\n      className: classNames(`${classPrefix}-track`, {\n        [`${classPrefix}-track-allow-touch-move`]: props.allowTouchMove\n      }),\n      onClickCapture: e => {\n        if (draggingRef.current) {\n          e.stopPropagation();\n        }\n\n        forceCancelDrag();\n      }\n    }, mergedProps), renderTrackInner()), props.indicator === undefined ? React.createElement(\"div\", {\n      className: `${classPrefix}-indicator`\n    }, React.createElement(PageIndicator, Object.assign({}, props.indicatorProps, {\n      total: count,\n      current: current,\n      direction: props.direction\n    }))) : props.indicator(count, current)));\n  };\n}));\n\nfunction modulus(value, division) {\n  const remainder = value % division;\n  return remainder < 0 ? remainder + division : remainder;\n}","map":null,"metadata":{},"sourceType":"module"}