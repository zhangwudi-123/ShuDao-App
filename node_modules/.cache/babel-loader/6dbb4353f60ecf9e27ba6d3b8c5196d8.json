{"ast":null,"code":"import React, { useMemo, useRef } from 'react';\nimport { withNativeProps } from '../../utils/native-props';\nimport classNames from 'classnames';\nimport Ticks from './ticks';\nimport Marks from './marks';\nimport getMiniDecimal, { toFixed } from '@rc-component/mini-decimal';\nimport Thumb from './thumb';\nimport { mergeProps } from '../../utils/with-default-props';\nimport { nearest } from '../../utils/nearest';\nimport { usePropsValue } from '../../utils/use-props-value';\nimport { devWarning } from '../../utils/dev-log';\nconst classPrefix = `adm-slider`;\nconst defaultProps = {\n  min: 0,\n  max: 100,\n  step: 1,\n  ticks: false,\n  range: false,\n  disabled: false,\n  popover: false,\n  residentPopover: false\n};\nexport const Slider = p => {\n  var _a;\n\n  const props = mergeProps(defaultProps, p);\n  const {\n    min,\n    max,\n    disabled,\n    marks,\n    ticks,\n    step,\n    icon\n  } = props;\n\n  function sortValue(val) {\n    return val.sort((a, b) => a - b);\n  }\n\n  function convertValue(value) {\n    return props.range ? value : [props.min, value];\n  }\n\n  function alignValue(value, decimalLen) {\n    const decimal = getMiniDecimal(value);\n    const fixedStr = toFixed(decimal.toString(), '.', decimalLen);\n    return getMiniDecimal(fixedStr).toNumber();\n  }\n\n  function reverseValue(value) {\n    const mergedDecimalLen = Math.max(getDecimalLen(step), getDecimalLen(value[0]), getDecimalLen(value[1]));\n    return props.range ? value.map(v => alignValue(v, mergedDecimalLen)) : alignValue(value[1], mergedDecimalLen);\n  }\n\n  function getDecimalLen(n) {\n    return (`${n}`.split('.')[1] || '').length;\n  }\n\n  function onAfterChange(value) {\n    var _a;\n\n    (_a = props.onAfterChange) === null || _a === void 0 ? void 0 : _a.call(props, reverseValue(value));\n  }\n\n  let propsValue = props.value;\n\n  if (props.range && typeof props.value === 'number') {\n    devWarning('Slider', 'When `range` prop is enabled, the `value` prop should be an array, like: [0, 0]');\n    propsValue = [0, props.value];\n  }\n\n  const [rawValue, setRawValue] = usePropsValue({\n    value: propsValue,\n    defaultValue: (_a = props.defaultValue) !== null && _a !== void 0 ? _a : props.range ? [min, min] : min,\n    onChange: props.onChange\n  });\n  const sliderValue = sortValue(convertValue(rawValue));\n\n  function setSliderValue(value) {\n    const next = sortValue(value);\n    const current = sliderValue;\n    if (next[0] === current[0] && next[1] === current[1]) return;\n    setRawValue(reverseValue(next));\n  }\n\n  const trackRef = useRef(null);\n  const fillSize = `${100 * (sliderValue[1] - sliderValue[0]) / (max - min)}%`;\n  const fillStart = `${100 * (sliderValue[0] - min) / (max - min)}%`; // 计算要显示的点\n\n  const pointList = useMemo(() => {\n    if (marks) {\n      return Object.keys(marks).map(parseFloat).sort((a, b) => a - b);\n    } else {\n      const points = [];\n\n      for (let i = getMiniDecimal(min); i.lessEquals(getMiniDecimal(max)); i = i.add(step)) {\n        points.push(i.toNumber());\n      }\n\n      return points;\n    }\n  }, [marks, ticks, step, min, max]);\n\n  function getValueByPosition(position) {\n    const newPosition = position < min ? min : position > max ? max : position;\n    let value = min; // 显示了刻度点，就只能移动到点上\n\n    if (pointList.length) {\n      value = nearest(pointList, newPosition);\n    } else {\n      const lengthPerStep = 100 / ((max - min) / step);\n      const steps = Math.round(newPosition / lengthPerStep);\n      value = steps * lengthPerStep * (max - min) * 0.01 + min;\n    }\n\n    return value;\n  }\n\n  const dragLockRef = useRef(0);\n\n  const onTrackClick = event => {\n    if (dragLockRef.current > 0) return;\n    event.stopPropagation();\n    if (disabled) return;\n    const track = trackRef.current;\n    if (!track) return;\n    const sliderOffsetLeft = track.getBoundingClientRect().left;\n    const position = (event.clientX - sliderOffsetLeft) / Math.ceil(track.offsetWidth) * (max - min) + min;\n    const targetValue = getValueByPosition(position);\n    let nextSliderValue;\n\n    if (props.range) {\n      // 移动的滑块采用就近原则\n      if (Math.abs(targetValue - sliderValue[0]) > Math.abs(targetValue - sliderValue[1])) {\n        nextSliderValue = [sliderValue[0], targetValue];\n      } else {\n        nextSliderValue = [targetValue, sliderValue[1]];\n      }\n    } else {\n      nextSliderValue = [props.min, targetValue];\n    }\n\n    setSliderValue(nextSliderValue);\n    onAfterChange(nextSliderValue);\n  };\n\n  const valueBeforeDragRef = useRef();\n\n  const renderThumb = index => {\n    return React.createElement(Thumb, {\n      key: index,\n      value: sliderValue[index],\n      min: min,\n      max: max,\n      disabled: disabled,\n      trackRef: trackRef,\n      icon: icon,\n      popover: props.popover,\n      residentPopover: props.residentPopover,\n      onDrag: (position, first, last) => {\n        if (first) {\n          dragLockRef.current += 1;\n          valueBeforeDragRef.current = sliderValue;\n        }\n\n        const val = getValueByPosition(position);\n        const valueBeforeDrag = valueBeforeDragRef.current;\n        if (!valueBeforeDrag) return;\n        const next = [...valueBeforeDrag];\n        next[index] = val;\n        setSliderValue(next);\n\n        if (last) {\n          onAfterChange(next);\n          window.setTimeout(() => {\n            dragLockRef.current -= 1;\n          }, 100);\n        }\n      },\n      \"aria-label\": props['aria-label']\n    });\n  };\n\n  return withNativeProps(props, React.createElement(\"div\", {\n    className: classNames(classPrefix, {\n      [`${classPrefix}-disabled`]: disabled\n    })\n  }, React.createElement(\"div\", {\n    className: `${classPrefix}-track-container`,\n    onClick: onTrackClick\n  }, React.createElement(\"div\", {\n    className: `${classPrefix}-track`,\n    onClick: onTrackClick,\n    ref: trackRef\n  }, React.createElement(\"div\", {\n    className: `${classPrefix}-fill`,\n    style: {\n      width: fillSize,\n      left: fillStart\n    }\n  }), props.ticks && React.createElement(Ticks, {\n    points: pointList,\n    min: min,\n    max: max,\n    lowerBound: sliderValue[0],\n    upperBound: sliderValue[1]\n  }), props.range && renderThumb(0), renderThumb(1))), marks && React.createElement(Marks, {\n    min: min,\n    max: max,\n    marks: marks,\n    lowerBound: sliderValue[0],\n    upperBound: sliderValue[1]\n  })));\n};","map":null,"metadata":{},"sourceType":"module"}