{"ast":null,"code":"import $ from 'dom7';\nimport Utils from '../../utils/utils';\nimport Framework7Class from '../../utils/class';\n\nclass Messages extends Framework7Class {\n  constructor(app) {\n    let params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    super(params, [app]);\n    const m = this;\n    const defaults = {\n      autoLayout: true,\n      messages: [],\n      newMessagesFirst: false,\n      scrollMessages: true,\n      scrollMessagesOnEdge: true,\n      firstMessageRule: undefined,\n      lastMessageRule: undefined,\n      tailMessageRule: undefined,\n      sameNameMessageRule: undefined,\n      sameHeaderMessageRule: undefined,\n      sameFooterMessageRule: undefined,\n      sameAvatarMessageRule: undefined,\n      customClassMessageRule: undefined,\n      renderMessage: undefined\n    }; // Extend defaults with modules params\n\n    m.useModulesParams(defaults);\n    m.params = Utils.extend(defaults, params);\n    const $el = $(params.el).eq(0);\n    if ($el.length === 0) return m;\n    if ($el[0].f7Messages) return $el[0].f7Messages;\n    $el[0].f7Messages = m;\n    const $pageContentEl = $el.closest('.page-content').eq(0);\n    Utils.extend(m, {\n      messages: m.params.messages,\n      $el,\n      el: $el[0],\n      $pageContentEl,\n      pageContentEl: $pageContentEl[0]\n    }); // Install Modules\n\n    m.useModules(); // Init\n\n    m.init();\n    return m;\n  } // eslint-disable-next-line\n\n\n  getMessageData(messageEl) {\n    const $messageEl = $(messageEl);\n    const data = {\n      name: $messageEl.find('.message-name').html(),\n      header: $messageEl.find('.message-header').html(),\n      textHeader: $messageEl.find('.message-text-header').html(),\n      textFooter: $messageEl.find('.message-text-footer').html(),\n      footer: $messageEl.find('.message-footer').html(),\n      isTitle: $messageEl.hasClass('messages-title'),\n      type: $messageEl.hasClass('message-sent') ? 'sent' : 'received',\n      text: $messageEl.find('.message-text').html(),\n      image: $messageEl.find('.message-image').html(),\n      imageSrc: $messageEl.find('.message-image img').attr('src'),\n      typing: $messageEl.hasClass('message-typing')\n    };\n\n    if (data.isTitle) {\n      data.text = $messageEl.html();\n    }\n\n    if (data.text && data.textHeader) {\n      data.text = data.text.replace(`<div class=\"message-text-header\">${data.textHeader}</div>`, '');\n    }\n\n    if (data.text && data.textFooter) {\n      data.text = data.text.replace(`<div class=\"message-text-footer\">${data.textFooter}</div>`, '');\n    }\n\n    let avatar = $messageEl.find('.message-avatar').css('background-image');\n    if (avatar === 'none' || avatar === '') avatar = undefined;\n\n    if (avatar && typeof avatar === 'string') {\n      avatar = avatar.replace('url(', '').replace(')', '').replace(/\"/g, '').replace(/'/g, '');\n    } else {\n      avatar = undefined;\n    }\n\n    data.avatar = avatar;\n    return data;\n  }\n\n  getMessagesData() {\n    const m = this;\n    const data = [];\n    m.$el.find('.message, .messages-title').each((index, messageEl) => {\n      data.push(m.getMessageData(messageEl));\n    });\n    return data;\n  }\n\n  renderMessage(messageToRender) {\n    const m = this;\n    const message = Utils.extend({\n      type: 'sent',\n      attrs: {}\n    }, messageToRender);\n\n    if (m.params.renderMessage) {\n      return m.params.renderMessage.call(m, message);\n    }\n\n    if (message.isTitle) {\n      return `<div class=\"messages-title\">${message.text}</div>`;\n    }\n\n    const attrs = Object.keys(message.attrs).map(attr => `${attr}=\"${message.attrs[attr]}\"`).join(' ');\n    return `\n      <div class=\"message message-${message.type} ${message.isTyping ? 'message-typing' : ''} ${message.cssClass || ''}\" ${attrs}>\n        ${message.avatar ? `\n        <div class=\"message-avatar\" style=\"background-image:url(${message.avatar})\"></div>\n        ` : ''}\n        <div class=\"message-content\">\n          ${message.name ? `<div class=\"message-name\">${message.name}</div>` : ''}\n          ${message.header ? `<div class=\"message-header\">${message.header}</div>` : ''}\n          <div class=\"message-bubble\">\n            ${message.textHeader ? `<div class=\"message-text-header\">${message.textHeader}</div>` : ''}\n            ${message.image ? `<div class=\"message-image\">${message.image}</div>` : ''}\n            ${message.imageSrc && !message.image ? `<div class=\"message-image\"><img src=\"${message.imageSrc}\"></div>` : ''}\n            ${message.text || message.isTyping ? `<div class=\"message-text\">${message.text || ''}${message.isTyping ? '<div class=\"message-typing-indicator\"><div></div><div></div><div></div></div>' : ''}</div>` : ''}\n            ${message.textFooter ? `<div class=\"message-text-footer\">${message.textFooter}</div>` : ''}\n          </div>\n          ${message.footer ? `<div class=\"message-footer\">${message.footer}</div>` : ''}\n        </div>\n      </div>\n    `;\n  }\n\n  renderMessages() {\n    let messagesToRender = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.messages;\n    let method = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.params.newMessagesFirst ? 'prepend' : 'append';\n    const m = this;\n    const html = messagesToRender.map(message => m.renderMessage(message)).join('');\n    m.$el[method](html);\n  }\n\n  isFirstMessage() {\n    const m = this;\n    if (m.params.firstMessageRule) return m.params.firstMessageRule(...arguments);\n    return false;\n  }\n\n  isLastMessage() {\n    const m = this;\n    if (m.params.lastMessageRule) return m.params.lastMessageRule(...arguments);\n    return false;\n  }\n\n  isTailMessage() {\n    const m = this;\n    if (m.params.tailMessageRule) return m.params.tailMessageRule(...arguments);\n    return false;\n  }\n\n  isSameNameMessage() {\n    const m = this;\n    if (m.params.sameNameMessageRule) return m.params.sameNameMessageRule(...arguments);\n    return false;\n  }\n\n  isSameHeaderMessage() {\n    const m = this;\n    if (m.params.sameHeaderMessageRule) return m.params.sameHeaderMessageRule(...arguments);\n    return false;\n  }\n\n  isSameFooterMessage() {\n    const m = this;\n    if (m.params.sameFooterMessageRule) return m.params.sameFooterMessageRule(...arguments);\n    return false;\n  }\n\n  isSameAvatarMessage() {\n    const m = this;\n    if (m.params.sameAvatarMessageRule) return m.params.sameAvatarMessageRule(...arguments);\n    return false;\n  }\n\n  isCustomClassMessage() {\n    const m = this;\n    if (m.params.customClassMessageRule) return m.params.customClassMessageRule(...arguments);\n    return undefined;\n  }\n\n  layout() {\n    const m = this;\n    m.$el.find('.message, .messages-title').each((index, messageEl) => {\n      const $messageEl = $(messageEl);\n\n      if (!m.messages) {\n        m.messages = m.getMessagesData();\n      }\n\n      const classes = [];\n      const message = m.messages[index];\n      const previousMessage = m.messages[index - 1];\n      const nextMessage = m.messages[index + 1];\n\n      if (m.isFirstMessage(message, previousMessage, nextMessage)) {\n        classes.push('message-first');\n      }\n\n      if (m.isLastMessage(message, previousMessage, nextMessage)) {\n        classes.push('message-last');\n      }\n\n      if (m.isTailMessage(message, previousMessage, nextMessage)) {\n        classes.push('message-tail');\n      }\n\n      if (m.isSameNameMessage(message, previousMessage, nextMessage)) {\n        classes.push('message-same-name');\n      }\n\n      if (m.isSameHeaderMessage(message, previousMessage, nextMessage)) {\n        classes.push('message-same-header');\n      }\n\n      if (m.isSameFooterMessage(message, previousMessage, nextMessage)) {\n        classes.push('message-same-footer');\n      }\n\n      if (m.isSameAvatarMessage(message, previousMessage, nextMessage)) {\n        classes.push('message-same-avatar');\n      }\n\n      let customMessageClasses = m.isCustomClassMessage(message, previousMessage, nextMessage);\n\n      if (customMessageClasses && customMessageClasses.length) {\n        if (typeof customMessageClasses === 'string') {\n          customMessageClasses = customMessageClasses.split(' ');\n        }\n\n        customMessageClasses.forEach(customClass => {\n          classes.push(customClass);\n        });\n      }\n\n      $messageEl.removeClass('message-first message-last message-tail message-same-name message-same-header message-same-footer message-same-avatar');\n      classes.forEach(className => {\n        $messageEl.addClass(className);\n      });\n    });\n  }\n\n  clear() {\n    const m = this;\n    m.messages = [];\n    m.$el.html('');\n  }\n\n  removeMessage(messageToRemove) {\n    let layout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    const m = this; // Index or El\n\n    let index;\n    let $el;\n\n    if (typeof messageToRemove === 'number') {\n      index = messageToRemove;\n      $el = m.$el.find('.message, .messages-title').eq(index);\n    } else if (m.messages && m.messages.indexOf(messageToRemove) >= 0) {\n      index = m.messages.indexOf(messageToRemove);\n      $el = m.$el.children().eq(index);\n    } else {\n      $el = $(messageToRemove);\n      index = $el.index();\n    }\n\n    if ($el.length === 0) {\n      return m;\n    }\n\n    $el.remove();\n    m.messages.splice(index, 1);\n    if (m.params.autoLayout && layout) m.layout();\n    return m;\n  }\n\n  removeMessages(messagesToRemove) {\n    let layout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    const m = this;\n\n    if (Array.isArray(messagesToRemove)) {\n      const messagesToRemoveEls = [];\n      messagesToRemove.forEach(messageToRemoveIndex => {\n        messagesToRemoveEls.push(m.$el.find('.message, .messages-title').eq(messageToRemoveIndex));\n      });\n      messagesToRemoveEls.forEach(messageToRemove => {\n        m.removeMessage(messageToRemove, false);\n      });\n    } else {\n      $(messagesToRemove).each((index, messageToRemove) => {\n        m.removeMessage(messageToRemove, false);\n      });\n    }\n\n    if (m.params.autoLayout && layout) m.layout();\n    return m;\n  }\n\n  addMessage() {\n    const m = this;\n    let messageToAdd;\n    let animate;\n    let method;\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    if (typeof args[1] === 'boolean') {\n      [messageToAdd, animate, method] = args;\n    } else {\n      [messageToAdd, method, animate] = args;\n    }\n\n    if (typeof animate === 'undefined') {\n      animate = true;\n    }\n\n    if (typeof method === 'undefined') {\n      method = m.params.newMessagesFirst ? 'prepend' : 'append';\n    }\n\n    return m.addMessages([messageToAdd], animate, method);\n  }\n\n  addMessages() {\n    const m = this;\n    let messagesToAdd;\n    let animate;\n    let method;\n\n    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n\n    if (typeof args[1] === 'boolean') {\n      [messagesToAdd, animate, method] = args;\n    } else {\n      [messagesToAdd, method, animate] = args;\n    }\n\n    if (typeof animate === 'undefined') {\n      animate = true;\n    }\n\n    if (typeof method === 'undefined') {\n      method = m.params.newMessagesFirst ? 'prepend' : 'append';\n    } // Define scroll positions before new messages added\n\n\n    const scrollHeightBefore = m.pageContentEl.scrollHeight;\n    const heightBefore = m.pageContentEl.offsetHeight;\n    const scrollBefore = m.pageContentEl.scrollTop; // Add message to DOM and data\n\n    let messagesHTML = '';\n    const typingMessage = m.messages.filter(el => el.isTyping)[0];\n    messagesToAdd.forEach(messageToAdd => {\n      if (typingMessage) {\n        if (method === 'append') {\n          m.messages.splice(m.messages.indexOf(typingMessage), 0, messageToAdd);\n        } else {\n          m.messages.splice(m.messages.indexOf(typingMessage) + 1, 0, messageToAdd);\n        }\n      } else {\n        m.messages[method === 'append' ? 'push' : 'unshift'](messageToAdd);\n      }\n\n      messagesHTML += m.renderMessage(messageToAdd);\n    });\n    const $messagesEls = $(messagesHTML);\n\n    if (animate) {\n      if (method === 'append' && !m.params.newMessagesFirst) {\n        $messagesEls.addClass('message-appear-from-bottom');\n      }\n\n      if (method === 'prepend' && m.params.newMessagesFirst) {\n        $messagesEls.addClass('message-appear-from-top');\n      }\n    }\n\n    if (typingMessage) {\n      if (method === 'append') {\n        $messagesEls.insertBefore(m.$el.find('.message-typing'));\n      } else {\n        $messagesEls.insertAfter(m.$el.find('.message-typing'));\n      }\n    } else {\n      m.$el[method]($messagesEls);\n    } // Layout\n\n\n    if (m.params.autoLayout) m.layout();\n\n    if (method === 'prepend' && !typingMessage) {\n      m.pageContentEl.scrollTop = scrollBefore + (m.pageContentEl.scrollHeight - scrollHeightBefore);\n    }\n\n    if (m.params.scrollMessages && (method === 'append' && !m.params.newMessagesFirst || method === 'prepend' && m.params.newMessagesFirst && !typingMessage)) {\n      if (m.params.scrollMessagesOnEdge) {\n        let onEdge = false;\n\n        if (m.params.newMessagesFirst && scrollBefore === 0) {\n          onEdge = true;\n        }\n\n        if (!m.params.newMessagesFirst && scrollBefore - (scrollHeightBefore - heightBefore) >= -10) {\n          onEdge = true;\n        }\n\n        if (onEdge) m.scroll(animate ? undefined : 0);\n      } else {\n        m.scroll(animate ? undefined : 0);\n      }\n    }\n\n    return m;\n  }\n\n  showTyping() {\n    let message = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const m = this;\n    const typingMessage = m.messages.filter(el => el.isTyping)[0];\n\n    if (typingMessage) {\n      m.removeMessage(m.messages.indexOf(typingMessage));\n    }\n\n    m.addMessage(Utils.extend({\n      type: 'received',\n      isTyping: true\n    }, message));\n    return m;\n  }\n\n  hideTyping() {\n    const m = this;\n    let typingMessageIndex;\n    let typingFound;\n    m.messages.forEach((message, index) => {\n      if (message.isTyping) typingMessageIndex = index;\n    });\n\n    if (typeof typingMessageIndex !== 'undefined') {\n      if (m.$el.find('.message').eq(typingMessageIndex).hasClass('message-typing')) {\n        typingFound = true;\n        m.removeMessage(typingMessageIndex);\n      }\n    }\n\n    if (!typingFound) {\n      const $typingMessageEl = m.$el.find('.message-typing');\n\n      if ($typingMessageEl.length) {\n        m.removeMessage($typingMessageEl);\n      }\n    }\n\n    return m;\n  }\n\n  scroll() {\n    let duration = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 300;\n    let scrollTop = arguments.length > 1 ? arguments[1] : undefined;\n    const m = this;\n    const currentScroll = m.pageContentEl.scrollTop;\n    let newScrollTop;\n    if (typeof scrollTop !== 'undefined') newScrollTop = scrollTop;else {\n      newScrollTop = m.params.newMessagesFirst ? 0 : m.pageContentEl.scrollHeight - m.pageContentEl.offsetHeight;\n      if (newScrollTop === currentScroll) return m;\n    }\n    m.$pageContentEl.scrollTop(newScrollTop, duration);\n    return m;\n  }\n\n  init() {\n    const m = this;\n\n    if (!m.messages || m.messages.length === 0) {\n      m.messages = m.getMessagesData();\n    }\n\n    if (m.params.messages && m.params.messages.length) {\n      m.renderMessages();\n    }\n\n    if (m.params.autoLayout) m.layout();\n    if (m.params.scrollMessages) m.scroll(0);\n  }\n\n  destroy() {\n    const m = this;\n    m.emit('local::beforeDestroy messagesBeforeDestroy', m);\n    m.$el.trigger('messages:beforedestroy');\n\n    if (m.$el[0]) {\n      m.$el[0].f7Messages = null;\n      delete m.$el[0].f7Messages;\n    }\n\n    Utils.deleteProps(m);\n  }\n\n}\n\nexport default Messages;","map":null,"metadata":{},"sourceType":"module"}